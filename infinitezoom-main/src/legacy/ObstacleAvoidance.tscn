[gd_scene load_steps=7 format=3 uid="uid://5oo14jq0fh8t"]

[sub_resource type="CSharpScript" id="CSharpScript_ecpbx"]
script/source = "using Godot;
using System;

public partial class obstacle_avoidance : Node3D
{
	[Export]
	Camera3D cam;

	[Export]
	RigidBody3D rig;

	[Export]
	Node3D container;

	[Export]
	float zoomEffectSpeed = 0.04f;

	float elapsedTime = 0;

	float spawnCooldown = 1.0f;

	float distanceBetween = 2.0f;

	MeshInstance3D obstacleMesh;

	float lastDuplicatePositionZ;


	bool dodge1 = false;

	bool dodge2 = false;

	float dodgeMovementSpeed = 0.2f; //distance the camera moves to avoid an obstacle

	float dodgeRotationSpeed = 0.01f;

	float dodgeRotationSpeedUpDown = 0.006f;

	int rotationFrames1 = 50; //frames it takes for the camera to perform the first dodge
	int rotationFrames2 = 50 * 2;

	int frameCounter = 0;

	bool obstacleDetected = false;

	enum DodgeDirection
	{
		Left,
		Right,
		Up,
		Down
	}

	enum ExperimentalDodgeDirection
	{
		LeftUp,
		RightUp,
		LeftDown,
		RightDown
	}

	DodgeDirection dodgeDirection;

	bool leftDetected = false;
	bool rightDetected = false;
	bool upDetected = false;
	bool downDetected = false;

	Area3D leftArea;
	Area3D rightArea;
	Area3D upArea;
	Area3D downArea;

	
	// Called when the node enters the scene tree for the first time.
	public override void _Ready()
	{
		GD.Print(\"Script1 initiated\");

		obstacleMesh = container.GetChild<MeshInstance3D>(0);
		lastDuplicatePositionZ = obstacleMesh.Position.Z;
	}
	void LeftAreaEntered(Area3D area)
	{
		if(area.GetParent().GetParent().Name == \"Container\"){
			GD.Print(\"Left Area Detection! \" + area);
			leftDetected = true;
			leftArea = area;
			obstacleDetected = true;
			dodgeDirection = DodgeDirection.Left;
		}
	}

	void RightAreaEntered(Area3D area)
	{
		if(area.GetParent().GetParent().Name == \"Container\"){
			GD.Print(\"Right Area Detection! \" + area);
			rightDetected = true;
			rightArea = area;
			obstacleDetected = true;
			dodgeDirection = DodgeDirection.Right;
		}
	}

	void UpAreaEntered(Area3D area)
	{
		if(area.GetParent().GetParent().Name == \"Container\"){
			GD.Print(\"Up Area Detection! \" + area);
			upDetected = true;
			upArea = area;
			obstacleDetected = true;
			dodgeDirection = DodgeDirection.Up;
		}
	}

	void DownAreaEntered(Area3D area)
	{
		if(area.GetParent().GetParent().Name == \"Container\"){
			GD.Print(\"Down Area Detection! \" + area);
			downDetected = true;
			downArea = area;
			obstacleDetected = true;
			dodgeDirection = DodgeDirection.Down;
		}
	}



	// Called every frame. 'delta' is the elapsed time since the previous frame.
	public override void _Process(double delta)
	{
		float deltaF = (float) delta;

		//obstacle spawning
		elapsedTime += (float) delta;

		if (elapsedTime >= spawnCooldown)
		{

			MeshInstance3D duplicate = (MeshInstance3D)obstacleMesh.Duplicate();
			Random r = new Random();
			double scaleMax = 0.5;
			double scaleMin = 0.1;

			float scale = (float)(r.NextDouble() * (scaleMax - scaleMin) + scaleMin);
			duplicate.Scale = new Vector3(scale, scale, scale);
			container.AddChild(duplicate);

			OrmMaterial3D material = new OrmMaterial3D
			{
				AlbedoColor = new Color((float)r.NextDouble(),
			(float)r.NextDouble(),
			(float)r.NextDouble())
			};

			duplicate.SetSurfaceOverrideMaterial(0, material);

			double max = 1;
			double min = -1;


			float randomX = (float)(duplicate.Position.X + (r.NextDouble() * (max - min) + min));
			float randomY = (float)(duplicate.Position.Y + (r.NextDouble() * (max - min) + min));

			duplicate.Position = new Vector3(randomX, randomY,
				lastDuplicatePositionZ - distanceBetween);
			lastDuplicatePositionZ -= distanceBetween;
			elapsedTime = 0;
		}

		// move all obstacles in \"container\" to the camera
		foreach(Node node in container.GetChildren())
		{
			MeshInstance3D obstacleMesh = (MeshInstance3D)node;

			float x = obstacleMesh.Position.X ;
			float y = obstacleMesh.Position.Y;
			float z = obstacleMesh.Position.Z + zoomEffectSpeed;

			obstacleMesh.Position = new Vector3(x, y, z);

			Random r = new Random();
			obstacleMesh.RotateX(r.Next(-1, 1) * 0.05f);
			obstacleMesh.RotateY(r.Next(-1, 1) * 0.05f);
			obstacleMesh.RotateZ(r.Next(-1, 1) * 0.05f);
		}


		//obstacle avoidance
		if (obstacleDetected && !dodge1 && !dodge2)
		{			
			dodge1 = true;
		}

		//make sure only one of the four detection booleans is true
		if(leftDetected && rightDetected)
		{
			GD.Print(Math.Abs(leftArea.GlobalPosition.X) + \" \" + Math.Abs(rightArea.GlobalPosition.X));

			if(Math.Abs(leftArea.GlobalPosition.X) < Math.Abs(rightArea.GlobalPosition.X))
			{
				rightDetected = false;
			}
			else
			{
				leftDetected = false;
			}
		}

		if(upDetected && downDetected)
		{
			GD.Print(Math.Abs(upArea.GlobalPosition.Y) + \" \" + Math.Abs(downArea.GlobalPosition.Y));

			if(Math.Abs(upArea.GlobalPosition.Y) < Math.Abs(downArea.GlobalPosition.Y))
			{
				downDetected = false;
			}
			else
			{
				upDetected = false;
			}
		}

		if(leftDetected && upDetected){
			if(Math.Abs(leftArea.GlobalPosition.X) < Math.Abs(upArea.GlobalPosition.Y))
			{
				upDetected = false;
			}
			else
			{
				leftDetected = false;
			}
		}else if(leftDetected && downDetected){
			if(Math.Abs(leftArea.GlobalPosition.X) < Math.Abs(downArea.GlobalPosition.Y))
			{
				downDetected = false;
			}
			else
			{
				leftDetected = false;
			}
		}else if(rightDetected && upDetected){
			if(Math.Abs(rightArea.GlobalPosition.X) < Math.Abs(upArea.GlobalPosition.Y))
			{
				upDetected = false;
			}
			else
			{
				rightDetected = false;
			}
		}else if(rightDetected && downDetected){
			if(Math.Abs(rightArea.GlobalPosition.X) < Math.Abs(downArea.GlobalPosition.Y))
			{
				downDetected = false;
			}
			else
			{
				rightDetected = false;
			}
		}


		if(leftDetected){
			//Dodge(-1 , deltaF);
			DodgeExperimental(-1, deltaF);
		}else if(rightDetected){
			//Dodge(1, deltaF);
		}else if(upDetected){
			//DodgeUpDown(-1, deltaF);
		}else if(downDetected){
			//DodgeUpDown(1, deltaF);
		}



	}

	void resetDetections()
	{
		leftDetected = false;
		rightDetected = false;
		upDetected = false;
		downDetected = false;
	}


	//--------------------------------------------------------------------------------------------
	// Obstacles Avoidance
	void DodgeExperimental(int direction, float delta){
		float t;
		float easedRotationSpeed;

		if (dodge1 && frameCounter <= rotationFrames1)
		{
			t = (float)frameCounter / rotationFrames1;
			easedRotationSpeed = dodgeRotationSpeed * MakeMovementCubic(t) * delta;
			cam.RotateZ(easedRotationSpeed * direction);
			cam.RotateX(easedRotationSpeed * direction);
			rig.ApplyImpulse(new Vector3(-1 * direction, 0, 0) * dodgeMovementSpeed);
			rig.ApplyImpulse(new Vector3(0, direction, 0) * dodgeMovementSpeed);
		}
		if (dodge1 && frameCounter == rotationFrames1 + 1)
		{
			dodge1 = false;
			dodge2 = true;
			rig.LinearVelocity = Vector3.Zero;
			rig.AngularVelocity = Vector3.Zero;
		}
		if (dodge2 && frameCounter <= rotationFrames2)
		{
			t = (float)(frameCounter - rotationFrames1 - 1) / (rotationFrames2 - rotationFrames1 - 1);
			easedRotationSpeed = dodgeRotationSpeed * MakeMovementCubic(t) * delta;
			cam.RotateZ(-easedRotationSpeed * direction);
			rig.ApplyImpulse(new Vector3(1 * direction, 0, 0) * dodgeMovementSpeed);
		}
		if (dodge2 && frameCounter == rotationFrames2 + 1)
		{
			dodge2 = false;
			obstacleDetected = false;
			frameCounter = 0;
			rig.LinearVelocity = Vector3.Zero;
			rig.AngularVelocity = Vector3.Zero;
			rig.GlobalPosition = new Vector3(0, rig.GlobalPosition.Y, rig.GlobalPosition.Z);
			resetDetections();
		}
	}


	void Dodge(int leftRight, float delta) {
		float t;
		float easedRotationSpeed;


		if (dodge1 && frameCounter <= rotationFrames1)
		{
			t = (float)frameCounter / rotationFrames1;
			easedRotationSpeed = dodgeRotationSpeed * MakeMovementCubic(t) * delta;
			cam.RotateZ(easedRotationSpeed * leftRight);
			rig.ApplyImpulse(new Vector3(-1 * leftRight, 0, 0) * dodgeMovementSpeed);
		}
		if (dodge1 && frameCounter == rotationFrames1 + 1)
		{
			dodge1 = false;
			dodge2 = true;
			rig.LinearVelocity = Vector3.Zero;
			rig.AngularVelocity = Vector3.Zero;
		}
		if (dodge2 && frameCounter <= rotationFrames2)
		{
			t = (float)(frameCounter - rotationFrames1 - 1) / (rotationFrames2 - rotationFrames1 - 1);
			easedRotationSpeed = dodgeRotationSpeed * MakeMovementCubic(t) * delta;
			cam.RotateZ(-easedRotationSpeed * leftRight);
			rig.ApplyImpulse(new Vector3(1 * leftRight, 0, 0) * dodgeMovementSpeed);
		}

		if (dodge2 && frameCounter == rotationFrames2 + 1)
		{
			dodge2 = false;
			obstacleDetected = false;
			frameCounter = 0;
			rig.LinearVelocity = Vector3.Zero;
			rig.AngularVelocity = Vector3.Zero;
			rig.GlobalPosition = new Vector3(0, rig.GlobalPosition.Y, rig.GlobalPosition.Z);
			resetDetections();
		}
		

		if (dodge1 || dodge2)
		{
			frameCounter++;
		}
	}

	void DodgeUpDown(int upDown, float delta){
		float t;
		float easedRotationSpeed;

		if (dodge1 && frameCounter <= rotationFrames1)
		{
			t = (float)frameCounter / rotationFrames1;
			easedRotationSpeed = dodgeRotationSpeedUpDown * MakeMovementCubic(t) * delta;
			cam.RotateX(easedRotationSpeed * upDown);
			rig.ApplyImpulse(new Vector3(0, upDown, 0) * dodgeMovementSpeed);
		}
		if (dodge1 && frameCounter == rotationFrames1 + 1)
		{
			dodge1 = false;
			dodge2 = true;
			rig.LinearVelocity = Vector3.Zero;
			rig.AngularVelocity = Vector3.Zero;
		}
		if (dodge2 && frameCounter <= rotationFrames2)
		{
			t = (float)(frameCounter - rotationFrames1 - 1) / (rotationFrames2 - rotationFrames1 - 1);
			easedRotationSpeed = dodgeRotationSpeedUpDown * MakeMovementCubic(t) * delta;
			cam.RotateX(-easedRotationSpeed * upDown);
			rig.ApplyImpulse(new Vector3(0, -upDown, 0) * dodgeMovementSpeed);
		}
		if (dodge2 && frameCounter == rotationFrames2 + 1)
		{
			dodge2 = false;
			obstacleDetected = false;
			frameCounter = 0;
			rig.LinearVelocity = Vector3.Zero;
			rig.AngularVelocity = Vector3.Zero;
			rig.GlobalPosition = new Vector3(rig.GlobalPosition.X, 0, rig.GlobalPosition.Z);
			resetDetections();
		}
		

		if (dodge1 || dodge2)
		{
			frameCounter++;
		}
	}


	float MakeMovementCubic(float t)
	{
		if (t < 0.5f)
			return 4 * t * t * t;
		return 1 - Mathf.Pow(-2 * t + 2, 3) / 2;
	}


}
"

[sub_resource type="BoxShape3D" id="BoxShape3D_tus6o"]

[sub_resource type="BoxShape3D" id="BoxShape3D_7de41"]
size = Vector3(1, 1, 0.175055)

[sub_resource type="BoxMesh" id="BoxMesh_76rk0"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_xos8u"]
metallic = 1.0
roughness = 0.5

[sub_resource type="BoxShape3D" id="BoxShape3D_7eakf"]

[node name="ZoomFov2" type="Node3D" node_paths=PackedStringArray("cam", "rig", "container")]
transform = Transform3D(0.683087, 0, 0, 0, 0.683087, 0, 0, 0, 0.683087, 0, 0, 0)
script = SubResource("CSharpScript_ecpbx")
cam = NodePath("camRB/Camera3D")
rig = NodePath("camRB")
container = NodePath("Container")

[node name="camRB" type="RigidBody3D" parent="."]
gravity_scale = 0.0

[node name="CollisionShape3D" type="CollisionShape3D" parent="camRB"]
shape = SubResource("BoxShape3D_tus6o")
disabled = true

[node name="Camera3D" type="Camera3D" parent="camRB"]
transform = Transform3D(1.31755, 0, 0, 0, 1.31755, 0, 0, 0, 1.31755, 0, 0, 0)
near = 0.06

[node name="LeftArea3D" type="Area3D" parent="camRB/Camera3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1.07524)

[node name="CollisionShape" type="CollisionShape3D" parent="camRB/Camera3D/LeftArea3D"]
transform = Transform3D(0.2, 0, 0, 0, 0.2, 0, 0, 0, 0.2, -0.1, 0, 0)
shape = SubResource("BoxShape3D_7de41")

[node name="RightArea3D" type="Area3D" parent="camRB/Camera3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1.07524)

[node name="CollisionShape" type="CollisionShape3D" parent="camRB/Camera3D/RightArea3D"]
transform = Transform3D(0.2, 0, 0, 0, 0.2, 0, 0, 0, 0.2, 0.1, 0, 0)
shape = SubResource("BoxShape3D_7de41")

[node name="UpArea3D" type="Area3D" parent="camRB/Camera3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1.07524)

[node name="CollisionShape" type="CollisionShape3D" parent="camRB/Camera3D/UpArea3D"]
transform = Transform3D(0.2, 0, 0, 0, 0.2, 0, 0, 0, 0.2, 0, 0.2, 0)
shape = SubResource("BoxShape3D_7de41")

[node name="DownArea3D" type="Area3D" parent="camRB/Camera3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1.07524)

[node name="CollisionShape" type="CollisionShape3D" parent="camRB/Camera3D/DownArea3D"]
transform = Transform3D(0.2, 0, 0, 0, 0.2, 0, 0, 0, 0.2, 0, -0.2, 0)
shape = SubResource("BoxShape3D_7de41")

[node name="Container" type="Node3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.0104465, -0.0298567, -10.6367)

[node name="ObstacleExample" type="MeshInstance3D" parent="Container"]
transform = Transform3D(0.05, 0, 0, 0, 0.05, 0, 0, 0, 0.05, 0, 0, -16.0236)
mesh = SubResource("BoxMesh_76rk0")
surface_material_override/0 = SubResource("StandardMaterial3D_xos8u")

[node name="Area3D" type="Area3D" parent="Container/ObstacleExample"]
transform = Transform3D(9.50779, 0, 0, 0, 9.79762, 0, 0, 0, 9.48315, 1.15185, -0.91577, 0.0443115)

[node name="CollisionShape3D" type="CollisionShape3D" parent="Container/ObstacleExample/Area3D"]
shape = SubResource("BoxShape3D_7eakf")

[connection signal="area_entered" from="camRB/Camera3D/LeftArea3D" to="." method="LeftAreaEntered"]
[connection signal="area_entered" from="camRB/Camera3D/RightArea3D" to="." method="RightAreaEntered"]
[connection signal="area_entered" from="camRB/Camera3D/UpArea3D" to="." method="UpAreaEntered"]
[connection signal="area_entered" from="camRB/Camera3D/DownArea3D" to="." method="DownAreaEntered"]
